<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshroom WebApp API Tester</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100vh;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .results {
            background: #1e1e1e;
            color: #f0f0f0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-family: 'Courier New', monospace;
            overflow-y: auto;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        h2 {
            color: #666;
            margin-top: 30px;
        }
        .endpoint-group {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        .file-input {
            margin: 10px 0;
        }
        .websocket-status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .ws-disconnected {
            background-color: #ffebee;
            color: #c62828;
        }
        .ws-connected {
            background-color: #e8f5e8;
            color: #2e7d32;
        }
        .response {
            margin: 10px 0;
            padding: 10px;
            border-left: 4px solid #4CAF50;
            background-color: #2a2a2a;
        }
        .response.error {
            border-left-color: #f44336;
        }
        .timestamp {
            color: #888;
            font-size: 12px;
        }
        .clear-btn {
            background-color: #ff9800;
            float: right;
        }
        .config-section {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h1>üöÄ Meshroom WebApp API Tester</h1>
            
            <!-- Configuration -->
            <div class="config-section">
                <h2>‚öôÔ∏è Configuration</h2>
                <label for="baseUrl">Backend URL:</label>
                <input type="text" id="baseUrl" value="http://localhost:8000" placeholder="http://localhost:8000">
                <button onclick="testConnection()">Test Connection</button>
            </div>

            <!-- Server Info -->
            <div class="endpoint-group">
                <h2>üìä Server Information</h2>
                <button onclick="getServerStatus()">GET / (Server Status)</button>
                <button onclick="getHealth()">GET /health (Health Check)</button>
                <button onclick="getQueueStatus()">GET /queue (Queue Status)</button>
                <button onclick="listJobs()">GET /jobs (List All Jobs)</button>
            </div>

            <!-- File Upload -->
            <div class="endpoint-group">
                <h2>üì§ File Upload</h2>
                <label for="fileInput">Select Images:</label>
                <input type="file" id="fileInput" accept="image/*" multiple class="file-input">
                
                <div>
                    <label for="parametersJson">Parameters (JSON):</label>
                    <textarea id="parametersJson" rows="6" style="width: 100%;" placeholder='{"quality":"medium"}'></textarea>
                    <small>Provide dynamic parameters as a JSON object. Leave empty to use server defaults.</small>
                </div>

                <button id="uploadBtn">Upload</button>
                <button onclick="generateDummyUpload()">Generate Dummy Upload</button>
            </div>

            <!-- Job Management -->
            <div class="endpoint-group">
                <h2>üîß Job Management</h2>
                <label for="jobId">Job ID:</label>
                <input type="text" id="jobId" placeholder="Enter job ID from upload response">
                
                <label for="jobSelect">Or select from existing jobs:</label>
                <select id="jobSelect" onchange="selectExistingJob()" style="margin-bottom: 10px;">
                    <option value="">-- Select an existing job --</option>
                </select>
                <button onclick="refreshJobList()" style="margin-left: 5px; padding: 5px 10px; font-size: 12px;">üîÑ Refresh</button>
                
                <button onclick="getJobStatus()">GET /jobs/{id} (Job Status)</button>
                <button onclick="downloadModel()">GET /jobs/{id}/download (Download Model)</button>
                <button onclick="cancelJob()">DELETE /jobs/{id} (Cancel Job)</button>
            </div>

            <!-- WebSocket -->
            <div class="endpoint-group">
                <h2>üîÑ Real-time Progress</h2>
                <div id="wsStatus" class="websocket-status ws-disconnected">WebSocket: Disconnected</div>
                <button onclick="connectWebSocket()" id="wsConnectBtn">Connect to WebSocket</button>
                <button onclick="disconnectWebSocket()" id="wsDisconnectBtn" disabled>Disconnect</button>
                <button onclick="sendPing()" id="wsPingBtn" disabled>Send Ping</button>
            </div>
        </div>

        <div class="results">
            <h2>üìã API Response Log 
                <button class="clear-btn" onclick="clearResults()">Clear</button>
            </h2>
            <div id="resultsContainer"></div>
        </div>
    </div>

    <script>
        let websocket = null;
        let currentJobId = null;

        function getTimestamp() {
            return new Date().toLocaleTimeString();
        }

        function addResult(title, data, isError = false) {
            const container = document.getElementById('resultsContainer');
            const div = document.createElement('div');
            div.className = 'response' + (isError ? ' error' : '');
            
            let content = `<div class="timestamp">[${getTimestamp()}] ${title}</div>`;
            if (typeof data === 'string') {
                content += `<pre>${data}</pre>`;
            } else {
                content += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
            }
            
            div.innerHTML = content;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function clearResults() {
            document.getElementById('resultsContainer').innerHTML = '';
        }

        function getBaseUrl() {
            return document.getElementById('baseUrl').value;
        }

        async function apiRequest(endpoint, options = {}) {
            const url = `${getBaseUrl()}${endpoint}`;
            try {
                addResult(`‚Üí ${options.method || 'GET'} ${endpoint}`, 'Sending request...');
                const response = await fetch(url, options);
                const contentType = response.headers.get('content-type');
                
                let responseData;
                if (contentType && contentType.includes('application/json')) {
                    responseData = await response.json();
                } else if (contentType && contentType.includes('application/octet-stream')) {
                    const blob = await response.blob();
                    responseData = `Binary file received: ${blob.size} bytes (${blob.type})`;
                    
                    // For model downloads, create a download link
                    if (endpoint.includes('/download')) {
                        const downloadUrl = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = downloadUrl;
                        a.download = `model_${currentJobId || 'unknown'}.glb`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(downloadUrl);
                        responseData += ' (Download started)';
                    }
                } else {
                    responseData = await response.text();
                }

                addResult(`‚úÖ ${response.status} ${response.statusText}`, responseData, !response.ok);
                return responseData;
            } catch (error) {
                addResult(`‚ùå Request Failed`, error.message, true);
                throw error;
            }
        }

        // Server Information APIs
        async function testConnection() {
            try {
                await apiRequest('/');
                addResult('üîó Connection Test', 'Backend is reachable!');
            } catch (error) {
                addResult('üîó Connection Test', 'Backend is not reachable!', true);
            }
        }

        async function getServerStatus() {
            await apiRequest('/');
        }

        async function getHealth() {
            await apiRequest('/health');
        }

        async function getQueueStatus() {
            await apiRequest('/queue');
        }

        async function listJobs() {
            return await apiRequest('/jobs');
        }

        /**
         * Parses and normalizes job list API responses into a consistent format
         * 
         * This utility function handles various response formats from the jobs API endpoint,
         * providing robust parsing for both direct array responses and object-wrapped responses.
         * It ensures consistent error handling and provides meaningful feedback messages.
         * 
         * @param {*} result - The raw API response result from /jobs endpoint
         * @returns {{jobs: Array<Object>|null, message: string, isError: boolean}} Normalized response object
         * @returns {Array<Object>|null} returns.jobs - Array of job objects, or null if parsing failed
         * @returns {string} returns.message - Human-readable message describing the parsing result
         * @returns {boolean} returns.isError - Whether an error occurred during parsing
         * 
         * @example
         * // Handle direct array response
         * const arrayResult = [{ job_id: '123', status: 'completed' }];
         * const parsed = parseJobsResponse(arrayResult);
         * // Returns: { jobs: [...], message: 'Found 1 jobs', isError: false }
         * 
         * @example
         * // Handle object-wrapped response
         * const wrappedResult = { jobs: [{ job_id: '456', status: 'queued' }] };
         * const parsed = parseJobsResponse(wrappedResult);
         * // Returns: { jobs: [...], message: 'Found 1 jobs', isError: false }
         * 
         * @example
         * // Handle error case
         * const errorResult = null;
         * const parsed = parseJobsResponse(errorResult);
         * // Returns: { jobs: null, message: 'No data received', isError: true }
         * 
         * @since 1.0.0
         */
        function parseJobsResponse(result) {
            if (!result) {
                return { jobs: null, message: 'No data received', isError: true };
            }
            
            // Handle direct array response
            if (Array.isArray(result)) {
                return { jobs: result, message: `Found ${result.length} jobs`, isError: false };
            }
            
            // Handle object-wrapped response (e.g., { jobs: [...] })
            if (typeof result === 'object' && Array.isArray(result.jobs)) {
                return { jobs: result.jobs, message: `Found ${result.jobs.length} jobs`, isError: false };
            }
            
            // Handle empty object response (valid but no jobs)
            if (typeof result === 'object' && result !== null) {
                return { jobs: [], message: 'No jobs found', isError: false };
            }
            
            // Handle unexpected response format
            return { jobs: null, message: 'Unexpected response format', isError: true };
        }

        /**
         * Creates an HTML option element for a job with a descriptive label
         * 
         * Generates a user-friendly option element that displays job information including
         * status, queue position (if queued), and creation timestamp for easy job identification.
         * 
         * @param {Object} job - Job object from the API response
         * @param {string} job.job_id - Unique identifier for the job
         * @param {string} [job.status] - Current status of the job (e.g., 'queued', 'processing', 'completed')
         * @param {string} [job.created_at] - ISO timestamp when the job was created
         * @param {number} [job.queue_position] - Position in queue (only for queued jobs, > 0)
         * @returns {HTMLOptionElement} A configured option element ready for insertion into a select dropdown
         * 
         * @example
         * const job = {
         *   job_id: '123-456-789',
         *   status: 'queued',
         *   created_at: '2025-08-21T19:30:00Z',
         *   queue_position: 2
         * };
         * const option = createJobOption(job);
         * // option.textContent = "123-456-789 - queued (pos: 2) (8/21/2025, 7:30:00 PM)"
         */
        function createJobOption(job) {
            const option = document.createElement('option');
            option.value = job.job_id;
            
            // Create a descriptive label with job status and timestamp
            const status = job.status || 'unknown';
            const timestamp = job.created_at ? new Date(job.created_at).toLocaleString() : 'unknown';
            const queuePos = job.queue_position > 0 ? ` (pos: ${job.queue_position})` : '';
            
            option.textContent = `${job.job_id} - ${status}${queuePos} (${timestamp})`;
            return option;
        }

        // Job Selection Functions
        async function refreshJobList() {
            try {
                const result = await apiRequest('/jobs');
                const jobSelect = document.getElementById('jobSelect');
                
                // Clear existing options (except the default one)
                jobSelect.innerHTML = '<option value="">-- Select an existing job --</option>';
                
                // Parse response using helper function
                const { jobs, message, isError } = parseJobsResponse(result);
                
                if (jobs && jobs.length > 0) {
                    // Populate dropdown with job options
                    jobs.forEach(job => {
                        const option = createJobOption(job);
                        jobSelect.appendChild(option);
                    });
                    addResult('‚úÖ Job List Refreshed', message);
                } else if (!isError) {
                    addResult('‚ÑπÔ∏è Job List', message);
                } else {
                    addResult('‚ùå Job List Error', message, true);
                }
            } catch (error) {
                addResult('‚ùå Job List Error', 'Failed to fetch job list', true);
            }
        }

        function selectExistingJob() {
            const jobSelect = document.getElementById('jobSelect');
            const selectedJobId = jobSelect.value;
            
            if (selectedJobId) {
                document.getElementById('jobId').value = selectedJobId;
                currentJobId = selectedJobId;
                addResult('‚ú® Job Selected', `Selected job: ${selectedJobId}`);
            }
        }

        // File Upload
        async function uploadImages() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;
            
            if (files.length === 0) {
                addResult('‚ùå Upload Error', 'No files selected', true);
                return;
            }

            const formData = new FormData();
            for (let file of files) {
                formData.append('files', file);
            }
            
            const paramsText = document.getElementById('parametersJson').value.trim();
            if (paramsText) {
                try {
                    JSON.parse(paramsText);
                    formData.append('parameters', paramsText);
                } catch (e) {
                    alert('Parameters JSON is invalid');
                    return;
                }
            }

            try {
                const result = await apiRequest('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                // Auto-populate job ID if upload successful
                if (result && result.job_id) {
                    document.getElementById('jobId').value = result.job_id;
                    currentJobId = result.job_id;
                    addResult('‚ú® Auto-filled', `Job ID: ${result.job_id}`);
                }
            } catch (error) {
                // Error already logged in apiRequest
            }
        }

        function generateDummyFile(filename, sizeKB = 1) {
            const data = new Uint8Array(sizeKB * 1024);
            // Fill with some dummy image-like data
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.floor(Math.random() * 256);
            }
            return new File([data], filename, { type: 'image/jpeg' });
        }

        async function generateDummyUpload() {
            const formData = new FormData();
            
            // Generate 3 dummy files
            for (let i = 1; i <= 3; i++) {
                const file = generateDummyFile(`dummy_image_${i}.jpg`, 2);
                formData.append('files', file);
            }
            
            formData.append('quality', 'medium');
            formData.append('max_features', '1000');
            formData.append('enable_gpu', 'false');

            try {
                const result = await apiRequest('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (result && result.job_id) {
                    document.getElementById('jobId').value = result.job_id;
                    currentJobId = result.job_id;
                    addResult('‚ú® Auto-filled', `Job ID: ${result.job_id}`);
                }
            } catch (error) {
                // Error already logged in apiRequest
            }
        }

        // Job Management
        async function getJobStatus() {
            const jobId = document.getElementById('jobId').value;
            if (!jobId) {
                addResult('‚ùå Job Status Error', 'Job ID is required', true);
                return;
            }
            await apiRequest(`/jobs/${jobId}`);
        }

        async function downloadModel() {
            const jobId = document.getElementById('jobId').value;
            if (!jobId) {
                addResult('‚ùå Download Error', 'Job ID is required', true);
                return;
            }
            currentJobId = jobId;
            await apiRequest(`/jobs/${jobId}/download`);
        }

        async function cancelJob() {
            const jobId = document.getElementById('jobId').value;
            if (!jobId) {
                addResult('‚ùå Cancel Error', 'Job ID is required', true);
                return;
            }
            await apiRequest(`/jobs/${jobId}`, { method: 'DELETE' });
        }

        // WebSocket Management
        function connectWebSocket() {
            const jobId = document.getElementById('jobId').value;
            if (!jobId) {
                addResult('‚ùå WebSocket Error', 'Job ID is required for WebSocket connection', true);
                return;
            }

            const wsUrl = getBaseUrl().replace('http', 'ws') + `/ws/${jobId}`;
            addResult('üîÑ WebSocket', `Connecting to: ${wsUrl}`);

            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = function(event) {
                addResult('‚úÖ WebSocket Connected', `Connected to job ${jobId}`);
                updateWebSocketStatus(true);
            };

            websocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addResult('üì® WebSocket Message', data);
                } catch (error) {
                    addResult('üì® WebSocket Message', event.data);
                }
            };

            websocket.onerror = function(error) {
                addResult('‚ùå WebSocket Error', error.message || 'Connection error', true);
            };

            websocket.onclose = function(event) {
                addResult('üîå WebSocket Closed', `Code: ${event.code}, Reason: ${event.reason}`);
                updateWebSocketStatus(false);
            };
        }

        function disconnectWebSocket() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
        }

        function sendPing() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send('ping');
                addResult('üì§ WebSocket Ping', 'Sent ping message');
            } else {
                addResult('‚ùå WebSocket Error', 'WebSocket not connected', true);
            }
        }

        function updateWebSocketStatus(connected) {
            const status = document.getElementById('wsStatus');
            const connectBtn = document.getElementById('wsConnectBtn');
            const disconnectBtn = document.getElementById('wsDisconnectBtn');
            const pingBtn = document.getElementById('wsPingBtn');

            if (connected) {
                status.textContent = 'WebSocket: Connected';
                status.className = 'websocket-status ws-connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                pingBtn.disabled = false;
            } else {
                status.textContent = 'WebSocket: Disconnected';
                status.className = 'websocket-status ws-disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                pingBtn.disabled = true;
            }
        }

        // Initialize
        window.onload = function() {
            addResult('üåü API Tester Ready', 'Welcome to Meshroom WebApp API Tester!');
            addResult('üí° Quick Start', '1. Make sure your backend is running\n2. Test connection\n3. Upload images or use dummy upload\n4. Monitor progress with WebSocket');
            
            // Auto-refresh job list on load
            refreshJobList();
        };

        // Auto-disconnect WebSocket on page unload
        window.onbeforeunload = function() {
            if (websocket) {
                websocket.close();
            }
        };

        document.getElementById('uploadBtn').addEventListener('click', uploadImages);
    </script>
</body>
</html>
